"""Admin API routes for LLM configuration management (CRUD)."""

from datetime import datetime

import structlog
from coaching.src.api.auth import get_current_context
from coaching.src.api.dependencies import get_llm_configuration_repository
from coaching.src.api.middleware.admin_auth import require_admin_access
from coaching.src.domain.entities.llm_config.llm_configuration import LLMConfiguration
from coaching.src.infrastructure.repositories.llm_config.llm_configuration_repository import (
    LLMConfigurationRepository,
)
from coaching.src.models.admin_requests import (
    CreateConfigurationRequest,
    UpdateConfigurationRequest,
)
from coaching.src.models.admin_responses import (
    ConfigurationDetail,
    ConfigurationsListResponse,
    ConfigurationSummary,
)
from fastapi import APIRouter, Body, Depends, HTTPException, Path, Query

from shared.models.multitenant import RequestContext
from shared.models.schemas import ApiResponse

logger = structlog.get_logger()
router = APIRouter()


@router.post("/configurations", response_model=ApiResponse[ConfigurationDetail], status_code=201)
async def create_configuration(
    request: CreateConfigurationRequest = Body(...),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[ConfigurationDetail]:
    """
    Create a new LLM configuration.

    Maps an interaction to a template and model with runtime parameters.
    Configuration becomes effective immediately unless effective_from is specified.

    **Permissions Required:** ADMIN_ACCESS

    **Request Body:**
    - interactionCode: Interaction code from INTERACTION_REGISTRY
    - templateId: Template ID (format: topic/version)
    - modelCode: Model code from MODEL_REGISTRY
    - tier: Optional tier restriction (null = all tiers)
    - temperature: LLM temperature (0.0-2.0, default: 0.7)
    - maxTokens: Maximum output tokens (default: 2000)
    - topP: Top-p sampling (0.0-1.0, default: 1.0)
    - frequencyPenalty: Frequency penalty (-2.0-2.0, default: 0.0)
    - presencePenalty: Presence penalty (-2.0-2.0, default: 0.0)
    - effectiveFrom: Optional start date (ISO format)
    - effectiveUntil: Optional end date (ISO format)

    **Returns:**
    - Configuration details with generated config_id

    **Note:** Consider running POST /admin/configurations/validate first
    to check for conflicts and parameter compatibility.
    """
    logger.info(
        "Creating configuration",
        admin_user_id=context.user_id,
        interaction_code=request.interaction_code,
        template_id=request.template_id,
        model_code=request.model_code,
        tier=request.tier,
    )

    try:
        # Parse dates if provided
        effective_from = (
            datetime.fromisoformat(request.effective_from)
            if request.effective_from
            else datetime.utcnow()
        )
        effective_until = (
            datetime.fromisoformat(request.effective_until) if request.effective_until else None
        )

        # Create configuration entity
        config = LLMConfiguration(
            config_id="",  # Will be generated by repository
            interaction_code=request.interaction_code,
            template_id=request.template_id,
            model_code=request.model_code,
            tier=request.tier,
            temperature=request.temperature,
            max_tokens=request.max_tokens,
            top_p=request.top_p,
            frequency_penalty=request.frequency_penalty,
            presence_penalty=request.presence_penalty,
            is_active=True,
            effective_from=effective_from,
            effective_until=effective_until,
            created_at=datetime.utcnow(),
            updated_at=datetime.utcnow(),
            created_by=context.user_id,
        )

        # Save configuration
        created_config = await config_repo.create(config)

        # Build response
        response_data = ConfigurationDetail(
            configId=created_config.config_id,
            interactionCode=created_config.interaction_code,
            templateId=created_config.template_id,
            modelCode=created_config.model_code,
            tier=created_config.tier,
            temperature=created_config.temperature,
            maxTokens=created_config.max_tokens,
            topP=created_config.top_p,
            frequencyPenalty=created_config.frequency_penalty,
            presencePenalty=created_config.presence_penalty,
            isActive=created_config.is_active,
            effectiveFrom=created_config.effective_from.isoformat(),
            effectiveUntil=(
                created_config.effective_until.isoformat()
                if created_config.effective_until
                else None
            ),
            createdAt=created_config.created_at.isoformat(),
            updatedAt=created_config.updated_at.isoformat(),
            createdBy=created_config.created_by,
        )

        logger.info(
            "Configuration created successfully",
            admin_user_id=context.user_id,
            config_id=created_config.config_id,
        )

        return ApiResponse(success=True, data=response_data)

    except ValueError as e:
        logger.error("Configuration creation failed (validation)", error=str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:
        logger.error("Configuration creation failed", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to create configuration") from e


@router.get("/configurations", response_model=ApiResponse[ConfigurationsListResponse])
async def list_configurations(
    interaction_code: str | None = Query(None, description="Filter by interaction code"),
    tier: str | None = Query(None, description="Filter by tier"),
    model_code: str | None = Query(None, description="Filter by model code"),
    template_id: str | None = Query(None, description="Filter by template ID"),
    active_only: bool = Query(False, description="Only return active configurations"),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[ConfigurationsListResponse]:
    """
    List LLM configurations with optional filters.

    Returns all configurations or filtered subset based on query parameters.
    Useful for viewing existing configurations and identifying conflicts.

    **Permissions Required:** ADMIN_ACCESS

    **Query Parameters:**
    - interaction_code: Filter by interaction code
    - tier: Filter by tier (null matches all-tier configs)
    - model_code: Filter by model code
    - template_id: Filter by template ID
    - active_only: Only show active configurations

    **Returns:**
    - List of configuration summaries
    - Total count and filtered count
    """
    logger.info(
        "Listing configurations",
        admin_user_id=context.user_id,
        interaction_code=interaction_code,
        tier=tier,
        active_only=active_only,
    )

    try:
        # Fetch configurations with filters
        configs = await config_repo.list_all(
            interaction_code=interaction_code,
            tier=tier,
            model_code=model_code,
            template_id=template_id,
            active_only=active_only,
        )

        # Convert to summary models
        summaries = [
            ConfigurationSummary(
                configId=cfg.config_id,
                interactionCode=cfg.interaction_code,
                templateId=cfg.template_id,
                modelCode=cfg.model_code,
                tier=cfg.tier,
                isActive=cfg.is_active,
                createdAt=cfg.created_at.isoformat(),
            )
            for cfg in configs
        ]

        response_data = ConfigurationsListResponse(
            configurations=summaries,
            totalCount=len(summaries),  # In real app, get total from DB
            filteredCount=len(summaries),
        )

        logger.info(
            "Configurations listed",
            admin_user_id=context.user_id,
            count=len(summaries),
        )

        return ApiResponse(success=True, data=response_data)

    except Exception as e:
        logger.error("Failed to list configurations", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to list configurations") from e


@router.get("/configurations/{config_id}", response_model=ApiResponse[ConfigurationDetail])
async def get_configuration(
    config_id: str = Path(..., description="Configuration ID"),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[ConfigurationDetail]:
    """
    Get configuration details by ID.

    Retrieves complete configuration including all parameters and metadata.

    **Permissions Required:** ADMIN_ACCESS

    **Path Parameters:**
    - config_id: Unique configuration identifier

    **Returns:**
    - Complete configuration details

    **Errors:**
    - 404: Configuration not found
    """
    logger.info(
        "Getting configuration",
        admin_user_id=context.user_id,
        config_id=config_id,
    )

    try:
        config = await config_repo.get_by_id(config_id)

        if not config:
            raise HTTPException(status_code=404, detail=f"Configuration not found: {config_id}")

        response_data = ConfigurationDetail(
            configId=config.config_id,
            interactionCode=config.interaction_code,
            templateId=config.template_id,
            modelCode=config.model_code,
            tier=config.tier,
            temperature=config.temperature,
            maxTokens=config.max_tokens,
            topP=config.top_p,
            frequencyPenalty=config.frequency_penalty,
            presencePenalty=config.presence_penalty,
            isActive=config.is_active,
            effectiveFrom=config.effective_from.isoformat(),
            effectiveUntil=config.effective_until.isoformat() if config.effective_until else None,
            createdAt=config.created_at.isoformat(),
            updatedAt=config.updated_at.isoformat(),
            createdBy=config.created_by,
        )

        logger.info(
            "Configuration retrieved",
            admin_user_id=context.user_id,
            config_id=config_id,
        )

        return ApiResponse(success=True, data=response_data)

    except HTTPException:
        raise
    except Exception as e:
        logger.error(
            "Failed to get configuration", config_id=config_id, error=str(e), exc_info=True
        )
        raise HTTPException(status_code=500, detail="Failed to get configuration") from e


@router.patch("/configurations/{config_id}", response_model=ApiResponse[ConfigurationDetail])
async def update_configuration(
    config_id: str = Path(..., description="Configuration ID"),
    request: UpdateConfigurationRequest = Body(...),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[ConfigurationDetail]:
    """
    Update an existing configuration (partial update).

    Updates only the fields provided in the request body.
    Cannot change interaction_code or tier (create new config instead).

    **Permissions Required:** ADMIN_ACCESS

    **Path Parameters:**
    - config_id: Configuration ID to update

    **Request Body (all optional):**
    - templateId: New template ID
    - modelCode: New model code
    - temperature: New temperature value
    - maxTokens: New max tokens
    - topP: New top-p value
    - frequencyPenalty: New frequency penalty
    - presencePenalty: New presence penalty
    - effectiveFrom: New effective from date
    - effectiveUntil: New effective until date

    **Returns:**
    - Updated configuration details

    **Errors:**
    - 404: Configuration not found
    """
    logger.info(
        "Updating configuration",
        admin_user_id=context.user_id,
        config_id=config_id,
    )

    try:
        # Get existing configuration
        config = await config_repo.get_by_id(config_id)

        if not config:
            raise HTTPException(status_code=404, detail=f"Configuration not found: {config_id}")

        # Update fields if provided
        if request.template_id is not None:
            config.template_id = request.template_id
        if request.model_code is not None:
            config.model_code = request.model_code
        if request.temperature is not None:
            config.temperature = request.temperature
        if request.max_tokens is not None:
            config.max_tokens = request.max_tokens
        if request.top_p is not None:
            config.top_p = request.top_p
        if request.frequency_penalty is not None:
            config.frequency_penalty = request.frequency_penalty
        if request.presence_penalty is not None:
            config.presence_penalty = request.presence_penalty
        if request.effective_from is not None:
            config.effective_from = datetime.fromisoformat(request.effective_from)
        if request.effective_until is not None:
            config.effective_until = datetime.fromisoformat(request.effective_until)

        # Save updated configuration
        updated_config = await config_repo.update(config)

        response_data = ConfigurationDetail(
            configId=updated_config.config_id,
            interactionCode=updated_config.interaction_code,
            templateId=updated_config.template_id,
            modelCode=updated_config.model_code,
            tier=updated_config.tier,
            temperature=updated_config.temperature,
            maxTokens=updated_config.max_tokens,
            topP=updated_config.top_p,
            frequencyPenalty=updated_config.frequency_penalty,
            presencePenalty=updated_config.presence_penalty,
            isActive=updated_config.is_active,
            effectiveFrom=updated_config.effective_from.isoformat(),
            effectiveUntil=(
                updated_config.effective_until.isoformat()
                if updated_config.effective_until
                else None
            ),
            createdAt=updated_config.created_at.isoformat(),
            updatedAt=updated_config.updated_at.isoformat(),
            createdBy=updated_config.created_by,
        )

        logger.info(
            "Configuration updated successfully",
            admin_user_id=context.user_id,
            config_id=config_id,
        )

        return ApiResponse(success=True, data=response_data)

    except HTTPException:
        raise
    except ValueError as e:
        logger.error("Configuration update failed (validation)", error=str(e))
        raise HTTPException(status_code=400, detail=str(e)) from e
    except Exception as e:
        logger.error("Configuration update failed", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to update configuration") from e


@router.delete("/configurations/{config_id}", response_model=ApiResponse[dict[str, str]])
async def delete_configuration(
    config_id: str = Path(..., description="Configuration ID"),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[dict[str, str]]:
    """
    Delete a configuration (hard delete).

    Permanently removes the configuration from the database.
    Consider using POST /admin/configurations/{config_id}/deactivate instead
    for soft delete that preserves history.

    **Permissions Required:** ADMIN_ACCESS

    **Path Parameters:**
    - config_id: Configuration ID to delete

    **Returns:**
    - Success message with deleted config_id

    **Errors:**
    - 404: Configuration not found

    **Warning:** This operation cannot be undone.
    """
    logger.info(
        "Deleting configuration",
        admin_user_id=context.user_id,
        config_id=config_id,
    )

    try:
        await config_repo.delete(config_id)

        logger.info(
            "Configuration deleted successfully",
            admin_user_id=context.user_id,
            config_id=config_id,
        )

        return ApiResponse(
            success=True,
            data={"message": "Configuration deleted successfully", "configId": config_id},
        )

    except ValueError as e:
        logger.error("Configuration not found for deletion", config_id=config_id)
        raise HTTPException(status_code=404, detail=str(e)) from e
    except Exception as e:
        logger.error("Configuration deletion failed", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to delete configuration") from e


@router.post("/configurations/{config_id}/deactivate", response_model=ApiResponse[dict[str, str]])
async def deactivate_configuration(
    config_id: str = Path(..., description="Configuration ID"),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[dict[str, str]]:
    """
    Deactivate a configuration (soft delete).

    Sets is_active to false, preserving the configuration in the database.
    Deactivated configurations won't be used for new requests but history is preserved.

    **Permissions Required:** ADMIN_ACCESS

    **Path Parameters:**
    - config_id: Configuration ID to deactivate

    **Returns:**
    - Success message with deactivated config_id

    **Errors:**
    - 404: Configuration not found
    """
    logger.info(
        "Deactivating configuration",
        admin_user_id=context.user_id,
        config_id=config_id,
    )

    try:
        await config_repo.deactivate(config_id)

        logger.info(
            "Configuration deactivated successfully",
            admin_user_id=context.user_id,
            config_id=config_id,
        )

        return ApiResponse(
            success=True,
            data={"message": "Configuration deactivated successfully", "configId": config_id},
        )

    except ValueError as e:
        logger.error("Configuration not found for deactivation", config_id=config_id)
        raise HTTPException(status_code=404, detail=str(e)) from e
    except Exception as e:
        logger.error("Configuration deactivation failed", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to deactivate configuration") from e


@router.post("/configurations/{config_id}/activate", response_model=ApiResponse[dict[str, str]])
async def activate_configuration(
    config_id: str = Path(..., description="Configuration ID"),
    context: RequestContext = Depends(get_current_context),
    _admin: RequestContext = Depends(require_admin_access),
    config_repo: LLMConfigurationRepository = Depends(get_llm_configuration_repository),
) -> ApiResponse[dict[str, str]]:
    """
    Activate a previously deactivated configuration.

    Sets is_active to true, allowing the configuration to be used again.

    **Permissions Required:** ADMIN_ACCESS

    **Path Parameters:**
    - config_id: Configuration ID to activate

    **Returns:**
    - Success message with activated config_id

    **Errors:**
    - 404: Configuration not found

    **Note:** Check for conflicts with other active configurations
    for the same interaction+tier before activating.
    """
    logger.info(
        "Activating configuration",
        admin_user_id=context.user_id,
        config_id=config_id,
    )

    try:
        await config_repo.activate(config_id)

        logger.info(
            "Configuration activated successfully",
            admin_user_id=context.user_id,
            config_id=config_id,
        )

        return ApiResponse(
            success=True,
            data={"message": "Configuration activated successfully", "configId": config_id},
        )

    except ValueError as e:
        logger.error("Configuration not found for activation", config_id=config_id)
        raise HTTPException(status_code=404, detail=str(e)) from e
    except Exception as e:
        logger.error("Configuration activation failed", error=str(e), exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to activate configuration") from e


__all__ = ["router"]
